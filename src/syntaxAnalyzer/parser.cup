/* Simple Toy language; parser evaluates constant expressions on the fly*/
package cupexample;
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer s;
    Parser(Lexer s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.nextToken(); :};

/* Terminals (tokens returned by the scanner). */
terminal        TRUE, FALSE, BOOLEAN, CLASS, DOUBLE, ELSE, EXTENDS, FOR, IF; // TODO ERROR IS POSSIBLY HERE?
terminal	    IMPLEMENTS, INTERFACE, NEW, NEWARRAY, PRINTLN, READLN, RETURN;
terminal	    STRING, THIS, VOID, WHILE, BREAK, NULL, INT, PLUS, MINUS, MULTIPLICATION;
terminal	    DIVISION, MOD, LESS, GREATER, LESSEQUAL, GREATEREQUAL, EQUAL, NOTEQUAL, AND, OR;
terminal	    NOT, ASSIGNOP, COMMA, SEMICOLON, PERIOD, LEFTPAREN, RIGHTPAREN, LEFTBRACKET, RIGHTBRACKET;// TODO the rest above need to be uppercased
terminal	    LEFTBRACE, RIGHTBRACE, INTCONSTANT, ID, STRINGCONSTANT, DOUBLECONSTANT; // these have been uppercased in the grammar rules section

/* Non terminals */
non terminal            Program, Decl, VariableDecl, Variable, Type, FunctionDecl, Formals, ClassDecl;
non terminal		Field, InterfaceDecl, Prototype, StmtBlock, Stmt, IfStmt, WhileStmt, ForStmt;
non terminal		BreakStmt, ReturnStmt, PrintStmt, Expr, Lvalue, Call, Actuals, Constant;

/* Precedences */
precedence left ASSIGNOP;
precedence left OR;
precedence left AND;
precedence left EQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION, MOD;
precedence left NOT;
precedence left LEFTBRACKET, PERIOD;

// TODO '+' character is unrecognized and ignored
/* The grammar rules */
Program ::= Decl+
;
Decl ::= VariableDecl
	| FunctionDecl
	| ClassDecl
	| InterfaceDecl
;
VariableDecl ::= Variable SEMICOLON
;
Variable ::= Type ID
;
Type ::= int
	| double
	| boolean
	| String
	| Type leftbracket rightbracket
	| ID
;
FunctionDecl ::= Type ID leftparen Formals rightparen StmtBlock
		| void ID leftparen Formals rightparen StmtBlock
;
Formals ::= Variable
		| Formals COMMA Formals
	    |
; // TODO comma, ',' in formals is causing an error
ClassDecl ::= CLASS ID <extends ID> <implements ID+,> LEFTBRACE Field* RIGHTBRACE
;
Field ::= VariableDecl
	| FunctionDecl
;
InterfaceDecl ::= interface ID LEFTBRACE Prototype* RIGHTBRACE
;
Prototype ::= Type ID leftparen Formals rightparen SEMICOLON
	     | void ID leftparen Formals rightparen SEMICOLON
;
StmtBlock ::= LEFTBRACE VariableDecl* Stmt* RIGHTBRACE
;
Stmt ::= <Expr> SEMICOLON
	| IfStmt
	| WhileStmt
	| ForStmt
	| BreakStmt
	| ReturnStmt
	| PrintStmt
	| StmtBlock
;
IfStmt ::= if leftparen Expr rightparen Stmt <else Stmt>
;
WhileStmt ::= while leftparen Expr rightparen Stmt
;
ForStmt ::= for leftparen <Expr> SEMICOLON Expr SEMICOLON <Expr> rightparen Stmt
;
BreakStmt ::= break SEMICOLON
;
ReturnStmt ::= return <Expr> SEMICOLON
;
PrintStmt ::= println leftparen Expr+, rightparen SEMICOLON
;
Expr ::= Lvalue assignop Expr
	| Constant
	| Lvalue
	| this
	| Call
	| leftparen Expr rightparen
	| Expr plus Expr
	| Expr minus Expr
	| Expr multiplication Expr
	| Expr division Expr
	| Expr mod Expr
	| minus Expr
	| Expr less Expr
	| Expr lessequal Expr
	| Expr greater Expr
	| Expr greaterequal Expr
	| Expr equal Expr
	| Expr notequal Expr
	| Expr and Expr
	| Expr or Expr
	| not Expr
	| readln leftparen rightparen
	| new leftparen ID rightparen
	| newarray leftparen INTCONSTANT comma Type rightparen
;
Lvalue ::= ID
	  | Lvalue leftbracket Expr rightbracket
	  | Lvalue period ID
;
Call ::= ID leftparen Actuals rightparen
	| ID period ID leftparen Actuals rightparen
;
Actuals ::= Expr+,
	   |
;
Constant ::= INTCONSTANT
	    | DOUBLECONSTANT
	    | STRINGCONSTANT
	    | BOOLEANCONSTANT
	    | NULL
;