/* Simple Toy language; parser evaluates constant expressions on the fly*/
package cupexample;
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer s;
    Parser(Lexer s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.nextToken(); :};

/* Terminals (tokens returned by the scanner). */
terminal        TRUE, FALSE, BOOLEAN, CLASS, DOUBLE, ELSE, EXTENDS, FOR, IF; // TODO ERROR IS POSSIBLY HERE?
terminal	    IMPLEMENTS, INTERFACE, NEW, NEWARRAY, PRINTLN, READLN, RETURN;
terminal	    STRING, THIS, VOID, WHILE, BREAK, NULL, INT, PLUS, MINUS, MULTIPLICATION;
terminal	    DIVISION, MOD, LESS, GREATER, LESSEQUAL, GREATEREQUAL, EQUAL, NOTEQUAL, AND, OR;
terminal	    NOT, ASSIGNOP, COMMA, SEMICOLON, PERIOD, LEFTPAREN, RIGHTPAREN, LEFTBRACKET, RIGHTBRACKET;// TODO the rest above need to be uppercased
terminal	    LEFTBRACE, RIGHTBRACE, INTCONSTANT, ID, STRINGCONSTANT, DOUBLECONSTANT; // these have been uppercased in the grammar rules section

/* Non terminals */
non terminal            program, decl, variabledecl, variable, type, functiondecl, formals, classdecl;
non terminal		field, interfacedecl, prototype, stmtblock, stmt, ifstmt, whilestmt, forstmt;
non terminal		breakstmt, returnstmt, printstmt, expr, lvalue, call, actuals, constant;
non terminal	 	declplus, variablecommplus, idcommplus, exprcommplus; // ALL OF THE NON TERMINALS TO FIX ISSUES

/* Precedences */
precedence left ASSIGNOP;
precedence left OR;
precedence left AND;
precedence left EQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION, MOD;
precedence left NOT;
precedence left LEFTBRACKET, PERIOD;

/* The grammar rules */
program ::= decl declplus
;
declplus ::= decl declplus // FIXES '+' PROBLEM
	   |
;
decl ::= variabledecl
	| functiondecl
	| classdecl
	| interfacedecl
;
variabledecl ::= variable SEMICOLON
;
variable ::= type ID
;
type ::= INT
	| DOUBLE
	| BOOLEAN
	| STRING
	| type LEFTBRACKET RIGHTBRACKET
	| ID
;
functiondecl ::= type ID LEFTPAREN formals RIGHTPAREN stmtblock
		| VOID ID LEFTPAREN formals RIGHTPAREN stmtblock
;
formals ::= variable variablecommplus
	   |
;
variablecommplus ::= COMMA variable variablecommplus // FIXES '+,' PROBLEM
		    |
;
classdecl ::= CLASS ID EXTENDS ID IMPLEMENTS ID idcommplus LEFTBRACE field* RIGHTBRACE // FIXES '<>' PROBLEM
	     | CLASS ID EXTENDS ID LEFTBRACE field* RIGHTBRACE
	     | CLASS ID IMPLEMENTS ID idcommplus LEFTBRACE field* RIGHTBRACE
	     | CLASS ID LEFTBRACE field* RIGHTBRACE
;
idcommplus ::= COMMA ID idcommplus // FIXES '+,' PROBLEM
	      |
;
field ::= variabledecl
	| functiondecl
;
interfacedecl ::= INTERFACE ID LEFTBRACE prototype* RIGHTBRACE
;
prototype ::= type ID LEFTPAREN formals RIGHTPAREN SEMICOLON
	     | VOID ID LEFTPAREN formals RIGHTPAREN SEMICOLON
;
stmtblock ::= LEFTBRACE variabledecl* stmt* RIGHTBRACE
;
stmt ::= expr SEMICOLON // FIXES '<>' PROBLEM
	| SEMICOLON
	| ifstmt
	| whilestmt
	| forstmt
	| breakstmt
	| returnstmt
	| printstmt
	| stmtblock
;
ifstmt ::= IF LEFTPAREN expr RIGHTPAREN stmt ELSE stmt // FIXES '<>' PROBLEM
	  | IF LEFTPAREN expr RIGHTPAREN stmt
;
whilestmt ::= WHILE LEFTPAREN expr RIGHTPAREN stmt
;
forstmt ::= FOR LEFTPAREN expr SEMICOLON expr SEMICOLON expr RIGHTPAREN stmt // FIXES '<>' PROBLEM
	   | FOR LEFTPAREN expr SEMICOLON expr SEMICOLON RIGHTPAREN stmt
	   | FOR LEFTPAREN SEMICOLON expr SEMICOLON expr RIGHTPAREN stmt
	   | FOR LEFTPAREN SEMICOLON expr SEMICOLON RIGHTPAREN stmt
;
breakstmt ::= BREAK SEMICOLON
;
returnstmt ::= RETURN expr SEMICOLON // FIXES '<>' PROBLEM
	     | RETURN SEMICOLON
;
printstmt ::= PRINTLN LEFTPAREN expr exprcommplus RIGHTPAREN SEMICOLON
;
exprcommplus ::= COMMA expr exprcommplus // FIXES '+,' PROBLEM
	       |
;
expr ::= lvalue ASSIGNOP expr
	| constant
	| lvalue
	| THIS
	| call
	| LEFTPAREN expr RIGHTPAREN
	| expr PLUS expr
	| expr MINUS expr
	| expr MULTIPLICATION expr
	| expr DIVISION expr
	| expr MOD expr
	| MINUS expr
	| expr LESS expr
	| expr LESSEQUAL expr
	| expr GREATER expr
	| expr GREATEREQUAL expr
	| expr EQUAL expr
	| expr NOTEQUAL expr
	| expr AND expr
	| expr OR expr
	| NOT expr
	| READLN LEFTPAREN RIGHTPAREN
	| NEW LEFTPAREN ID RIGHTPAREN
	| NEWARRAY LEFTPAREN INTCONSTANT COMMA type RIGHTPAREN
;
lvalue ::= ID
	  | lvalue LEFTBRACKET expr RIGHTBRACKET
	  | lvalue PERIOD ID
;
call ::= ID LEFTPAREN actuals RIGHTPAREN
	| ID PERIOD ID LEFTPAREN actuals RIGHTPAREN
;
actuals ::= expr exprcommplus
	   |
;
constant ::= INTCONSTANT
	    | DOUBLECONSTANT
	    | STRINGCONSTANT
	    | BOOLEANCONSTANT
	    | NULL
;