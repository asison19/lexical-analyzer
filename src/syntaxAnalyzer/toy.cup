/* Simple Toy language; parser evaluates constant expressions on the fly*/

// requires java-cup-11b-runtime.jar
package syntaxAnalyzer;

import java_cup.runtime.*;
import lexicalAnalyzer.*; // Project 1

class ToyParser;

action code{:
	// User Generated Code

	// output the reductions and their production numbers
	// this assumes the Object is an Integer and is used when RESULT
	// is being used to hold the production number.
	private String reduction(Object... reductions) {
		String str = "";
		for(Object i: reductions) {
			str += "[reduce " + i + "]";
		}
		
		return str;
	}
:}

parser code {:
    // User Generated Code
	
	
    ToyLexer s;
	@SuppressWarnings("deprecation")
    public ToyParser(ToyLexer s){ this.s=s; }
	
	
:}

/* define how to connect to the scanner! */
// init with {: s.init(); :};

// scan with {: return s.yylex(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal        TRUE, FALSE, BOOLEAN, CLASS, DOUBLE, ELSE, EXTENDS, FOR, IF; // TODO ERROR IS POSSIBLY HERE?
terminal	    IMPLEMENTS, INTERFACE, NEW, NEWARRAY, PRINTLN, READLN, RETURN;
terminal	    STRING, THIS, VOID, WHILE, BREAK, NULL, INT, PLUS, MINUS, MULTIPLICATION;
terminal	    DIVISION, MOD, LESS, GREATER, LESSEQUAL, GREATEREQUAL, EQUAL, NOTEQUAL, AND, OR;
terminal	    NOT, ASSIGNOP, COMMA, SEMICOLON, PERIOD, LEFTPAREN, RIGHTPAREN, LEFTBRACKET, RIGHTBRACKET;// TODO the rest above need to be uppercased
terminal	    LEFTBRACE, RIGHTBRACE, INTCONSTANT, ID, STRINGCONSTANT, DOUBLECONSTANT, BOOLEANCONSTANT; // these have been uppercased in the grammar rules section

/* Non terminals */
non terminal        program, decl, variabledecl, variable, type, functiondecl, formals, classdecl;
non terminal		field, interfacedecl, prototype, stmtblock, stmt, ifstmt, whilestmt, forstmt;
non terminal		breakstmt, returnstmt, printstmt, expr, lvalue, call, actuals, constant;
non terminal	 	declplus, variablecommplus, idcommplus, exprcommplus, fieldstar, prototypestar, variabledeclstar, stmtstar; // ALL OF THE NON TERMINALS TO FIX ISSUES

/* Precedences */
precedence left ASSIGNOP;
precedence left OR;
precedence left AND;
precedence left EQUAL, NOTEQUAL;
precedence left LESS, LESSEQUAL, GREATER, GREATEREQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLICATION, DIVISION, MOD;
precedence left NOT;
precedence left LEFTBRACKET, PERIOD;
precedence left ELSE; // FIXES SR DANGLING ELSE PROBLEM

/****************************** The grammar rules ******************************/
// In this program, RESULT is an object of type java.lang.Integer, and holds the value of the production number
// 
// The RESULT variable refers directly to the value of the non-terminal to which a rule reduces
// Information take from CUP documentation here: http://www2.cs.tum.edu/projects/cup/docs.php

// Production # 0101 // CUP$ToyParser$act_num this counts as grammar rule?
program 		::= decl:d declplus:d2 				{: RESULT = 101; System.out.print(reduction(d,d2)); :}
;

// Production # 0201 0202
declplus 		::= decl:d declplus:d2 				{: RESULT = 201; System.out.print(reduction(d,d2)); :}// FIXES '+' PROBLEM
				|									{: RESULT = 202; :} 
;

// Production # 0301 0302 0303
decl 			::= variabledecl:v 					{: RESULT = 301; System.out.print(reduction(v)); :}
				| functiondecl:f					{: RESULT = 302; System.out.print(reduction(f)); :}
				| classdecl:c						{: RESULT = 303;  System.out.print(reduction(c));:}
				| interfacedecl:i					{: RESULT = 304; System.out.print(reduction(i)); :}
;

// Production # 0401
variabledecl 	::= variable:v SEMICOLON 			{: RESULT = 401; System.out.print(reduction(v) + "\nSEMICOLON [shift]\n"); :}
;

// Production # 0501
variable 		::= type:t ID 						{: RESULT = 501; System.out.println("ID " + reduction(t)+ "[shift]"); :}
;

// Production # 0601
type 			::= INT:n 							{: RESULT = 601; System.out.println("INT " + "[shift]"); :}
				| DOUBLE 							{: RESULT = 602; System.out.println("DOUBLE [shift]"); :}
				| BOOLEAN 							{: RESULT = 603; System.out.println("BOOLEAN [shift]"); :}
				| STRING 							{: RESULT = 604; System.out.println("STRING [shift]"); :}
				| type:t LEFTBRACKET RIGHTBRACKET 	{: RESULT = 605; System.out.println(reduction(t) + "LEFTBRACKET [shift]\n" + "RIGHTBRACKET [shift]\n"); :}
				| ID 								{: RESULT = 606; System.out.println("ID [shift]"); :}
;

// Production # 07
functiondecl 	::= type ID LEFTPAREN formals RIGHTPAREN stmtblock	{: RESULT = 701; :}
				| VOID ID LEFTPAREN formals RIGHTPAREN stmtblock	{: RESULT = 702; :}
;

// Production # 08
formals 		::= variable variablecommplus		{: RESULT = 801; :}
				|									{: RESULT = 802; :}
;

// Production # 09
variablecommplus 	::= COMMA variable variablecommplus {: RESULT = 901; :}// FIXES '+,' PROBLEM
					|									{: RESULT = 902; :}
;

// Production # 10
classdecl 		::= CLASS ID EXTENDS ID IMPLEMENTS ID idcommplus LEFTBRACE fieldstar RIGHTBRACE {: RESULT = 1001; :}// FIXES '<>' PROBLEM
				| CLASS ID EXTENDS ID IMPLEMENTS ID idcommplus LEFTBRACE RIGHTBRACE				{: RESULT = 1002; :}
				| CLASS ID EXTENDS ID LEFTBRACE fieldstar RIGHTBRACE							{: RESULT = 1003; :}
				| CLASS ID EXTENDS ID LEFTBRACE RIGHTBRACE										{: RESULT = 1004; :}
				| CLASS ID IMPLEMENTS ID idcommplus LEFTBRACE fieldstar RIGHTBRACE				{: RESULT = 1005; :}
				| CLASS ID IMPLEMENTS ID idcommplus LEFTBRACE RIGHTBRACE						{: RESULT = 1006; :}
				| CLASS ID LEFTBRACE fieldstar RIGHTBRACE										{: RESULT = 1007; :}
				| CLASS ID LEFTBRACE RIGHTBRACE													{: RESULT = 1008; :}
;

// Production # 11
fieldstar ::= field fieldstar 			{: RESULT = 1101; :}// FIXES '*' PROBLEM
;

// Production # 12
idcommplus ::= COMMA ID idcommplus 		{: RESULT = 1201; :}// FIXES '+,' PROBLEM
	      |								{: RESULT = 1202; :}
;

// Production # 13
field ::= variabledecl					{: RESULT = 1301; :}
	| functiondecl						{: RESULT = 1302; :}
;

// Production # 14
interfacedecl ::= INTERFACE ID LEFTBRACE prototypestar RIGHTBRACE		{: RESULT = 1401; :}
		  | INTERFACE ID LEFTBRACE RIGHTBRACE							{: RESULT = 1402; :}
;

// Production # 15
prototypestar ::= prototype prototypestar 								{: RESULT = 1501; :} // FIXED '*' PROBLEM
;

// Production # 16
prototype ::= type ID LEFTPAREN formals RIGHTPAREN SEMICOLON			{: RESULT = 1601; :}
	     | VOID ID LEFTPAREN formals RIGHTPAREN SEMICOLON				{: RESULT = 1602; :}
;

// Production # 17
stmtblock ::= LEFTBRACE variabledeclstar stmtstar RIGHTBRACE			{: RESULT = 1701; :}
	     | LEFTBRACE stmtstar RIGHTBRACE								{: RESULT = 1702; :}
	     | LEFTBRACE variabledeclstar RIGHTBRACE						{: RESULT = 1703; :}
	     | LEFTBRACE RIGHTBRACE											{: RESULT = 1704; :}
;

// Production # 18 // FIXED '*' PROBLEM
variabledeclstar ::= variabledecl variabledeclstar 						{: RESULT = 1801; :} 
;

// Production # 19 // FIXED '*' PROBLEM
stmtstar ::= stmt stmtstar 												{: RESULT = 1901; :} 
;

// Production # 20 // FIXES '<>' PROBLEM
stmt ::= expr SEMICOLON 												{: RESULT = 2001; :} 
	| SEMICOLON			 												{: RESULT = 2002; :} 
	| ifstmt			 												{: RESULT = 2003; :} 
	| whilestmt			 												{: RESULT = 2004; :} 
	| forstmt			 												{: RESULT = 2005; :} 
	| breakstmt			 												{: RESULT = 2006; :} 
	| returnstmt			 											{: RESULT = 2007; :} 
	| printstmt			 												{: RESULT = 2008; :} 
	| stmtblock			 												{: RESULT = 2009; :} 
;

// Production # 21 // FIXES '<>' PROBLEM
ifstmt ::= IF LEFTPAREN expr RIGHTPAREN stmt ELSE stmt 					{: RESULT = 2101; :} 
	  | IF LEFTPAREN expr RIGHTPAREN stmt								{: RESULT = 2102; :} 
;

// Production # 22
whilestmt ::= WHILE LEFTPAREN expr RIGHTPAREN stmt						{: RESULT = 2201; :} 
;

// Production # 23 // FIXES '<>' PROBLEM
forstmt ::= FOR LEFTPAREN expr SEMICOLON expr SEMICOLON expr RIGHTPAREN stmt 	{: RESULT = 2301; :} 
	   | FOR LEFTPAREN expr SEMICOLON expr SEMICOLON RIGHTPAREN stmt			{: RESULT = 2302; :} 
	   | FOR LEFTPAREN SEMICOLON expr SEMICOLON expr RIGHTPAREN stmt			{: RESULT = 2303; :} 
	   | FOR LEFTPAREN SEMICOLON expr SEMICOLON RIGHTPAREN stmt					{: RESULT = 2304; :} 
;

// Production # 24
breakstmt ::= BREAK SEMICOLON						{: RESULT = 2401; :} 
;

// Production # 25 // FIXES '<>' PROBLEM
returnstmt ::= RETURN expr SEMICOLON 				{: RESULT = 2501; :} 
	     | RETURN SEMICOLON							{: RESULT = 2502; :} 
;

// Production # 26
printstmt ::= PRINTLN LEFTPAREN expr exprcommplus RIGHTPAREN SEMICOLON			{: RESULT = 2601; :} 
;

// Production # 27 // FIXES '+,' PROBLEM
exprcommplus ::= COMMA expr exprcommplus 			{: RESULT = 2701; :} 
	       |										{: RESULT = 2702; :} 
;

// Production # 28
expr ::= lvalue ASSIGNOP expr									{: RESULT = 2801; :} 
	| constant													{: RESULT = 2802; :} 
	| lvalue													{: RESULT = 2803; :} 
	| THIS														{: RESULT = 2804; :} 
	| call														{: RESULT = 2805; :} 
	| LEFTPAREN expr RIGHTPAREN									{: RESULT = 2806; :} 
	| expr PLUS expr											{: RESULT = 2807; :} 
	| expr MINUS expr											{: RESULT = 2808; :} 
	| expr MULTIPLICATION expr									{: RESULT = 2809; :} 
	| expr DIVISION expr										{: RESULT = 2810; :} 
	| expr MOD expr												{: RESULT = 2811; :} 
	| MINUS expr												{: RESULT = 2812; :} 
	| expr LESS expr											{: RESULT = 2813; :} 
	| expr LESSEQUAL expr										{: RESULT = 2814; :} 
	| expr GREATER expr											{: RESULT = 2815; :} 
	| expr GREATEREQUAL expr									{: RESULT = 2816; :} 
	| expr EQUAL expr											{: RESULT = 2817; :} 
	| expr NOTEQUAL expr										{: RESULT = 2818; :} 
	| expr AND expr												{: RESULT = 2819; :} 
	| expr OR expr												{: RESULT = 2820; :} 
	| NOT expr													{: RESULT = 2821; :} 
	| READLN LEFTPAREN RIGHTPAREN								{: RESULT = 2822; :} 
	| NEW LEFTPAREN ID RIGHTPAREN								{: RESULT = 2823; :} 
	| NEWARRAY LEFTPAREN INTCONSTANT COMMA type RIGHTPAREN		{: RESULT = 2824; :} 
;

// Production # 29 // FIXED SR AND RR ISSUES HERE
lvalue ::= ID LEFTBRACKET expr RIGHTBRACKET 					{: RESULT = 2901; :} 
	  | ID PERIOD ID											{: RESULT = 2902; :} 
	  | lvalue LEFTBRACKET expr RIGHTBRACKET					{: RESULT = 2903; :} 
	  | lvalue PERIOD ID										{: RESULT = 2904; :} 
;

// Production # 30
call ::= ID LEFTPAREN actuals:a RIGHTPAREN						{: RESULT = 3001; System.out.print("ID [shift]\nLEFTPAREN [shift]" + reduction(a) + "RIGHTPARENT [shift]\n"); :} 
	| ID PERIOD ID LEFTPAREN actuals:a RIGHTPAREN				{: RESULT = 3002; System.out.print("ID [shift]\nPERIOD [shift]\nID [shift]\nLEFTPAREN [shift]\n" + reduction(a) + "RIGHTPAREN [shift]\n"); :} 
;

// Production # 31
actuals ::= expr:e1 exprcommplus:e2								{: RESULT = 3101; System.out.print(reduction(e1,e2)); :} 
	   |														{: RESULT = 3102; :} 
;

// Production # 32
constant ::= INTCONSTANT										{: RESULT = 3201; System.out.println("INTCONSTANT [shift]"); :} 
	    | DOUBLECONSTANT										{: RESULT = 3202; System.out.println("DOUBLECONSTANT [shift]"); :} 
	    | STRINGCONSTANT										{: RESULT = 3203; System.out.println("STRINGCONSTANT [shift]"); :} 
	    | BOOLEANCONSTANT										{: RESULT = 3204; System.out.println("BOOLEANCONSTANT [shift]"); :} 
	    | NULL													{: RESULT = 3205; System.out.println("NULL [shift]"); :} 
;
